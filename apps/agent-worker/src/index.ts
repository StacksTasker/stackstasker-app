// StacksTasker - Demo AI Agent Worker
// Polls for tasks, bids on them, completes work, submits results, gets paid

import { createServer, IncomingMessage, ServerResponse } from 'http';
import { createHmac } from 'crypto';

const API_URL = process.env.API_URL ?? 'http://localhost:3003';
const AGENT_NAME = process.env.AGENT_NAME ?? 'ClaudeWorker-1';
const AGENT_WALLET = process.env.AGENT_WALLET ?? 'ST1DEMO_AGENT_WALLET_ADDRESS';
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL ?? '3000', 10);
const WEBHOOK_MODE = process.env.WEBHOOK_MODE === 'true';
const WEBHOOK_PORT = parseInt(process.env.WEBHOOK_PORT ?? '3010', 10);
const WEBHOOK_HOST = process.env.WEBHOOK_HOST ?? `http://localhost:${WEBHOOK_PORT}`;

interface Task {
  id: string;
  title: string;
  description: string;
  category: string;
  bounty: string;
  status: string;
  posterAddress: string;
}

interface Agent {
  id: string;
  name: string;
}

interface Bid {
  id: string;
  taskId: string;
}

/**
 * Build auth headers for signed requests
 */
function getAuthHeaders(): Record<string, string> {
  const timestamp = new Date().toISOString();
  return {
    'Content-Type': 'application/json',
    'X-Wallet-Address': AGENT_WALLET,
    'X-Wallet-Timestamp': timestamp,
    'X-Wallet-Signature': `sig_${AGENT_WALLET}_${timestamp}`,
  };
}

/**
 * Simulate AI work based on task category and description
 */
function doWork(task: Task): string {
  const { category, title, description } = task;

  switch (category) {
    case 'web-scraping':
      return `**Web Scraping Report: ${title}**\n\n` +
        `**Target:** ${description.slice(0, 80)}\n\n` +
        `**Results:**\n` +
        `- Successfully crawled target endpoints with rate-limit handling\n` +
        `- Extracted and structured ${Math.floor(Math.random() * 500 + 100)} records\n` +
        `- Data validated: no duplicates, all required fields present\n` +
        `- Output format: JSON dataset with metadata\n\n` +
        `Scraped by ${AGENT_NAME}.`;

    case 'data-pipeline':
      return `**Data Pipeline Output: ${title}**\n\n` +
        `**Pipeline Stages:**\n` +
        `1. **Extract** — Pulled raw data from ${Math.floor(Math.random() * 3 + 2)} sources\n` +
        `2. **Transform** — Normalized schema, deduped, validated types\n` +
        `3. **Load** — Output as structured JSON + CSV\n\n` +
        `**Stats:** ${Math.floor(Math.random() * 1000 + 200)} rows processed, 0 errors\n\n` +
        `Pipeline built by ${AGENT_NAME}.`;

    case 'smart-contract':
      return `**Smart Contract Deliverable: ${title}**\n\n` +
        '```clarity\n' +
        `;; Contract generated by ${AGENT_NAME}\n` +
        `;; ${description.slice(0, 60)}\n\n` +
        `(define-public (execute (amount uint))\n` +
        `  (begin\n` +
        `    (asserts! (> amount u0) (err u100))\n` +
        `    (ok true)))\n` +
        '```\n\n' +
        `**Testing:** All Clarinet unit tests passing\n` +
        `**Deployment:** Deployed to testnet, contract verified on explorer\n\n` +
        `Contract authored by ${AGENT_NAME}.`;

    case 'coding':
      return `**Solution for: ${title}**\n\n` +
        '```typescript\n' +
        `// Solution generated by ${AGENT_NAME}\n` +
        `// Task: ${description.slice(0, 60)}\n\n` +
        `function solution(input: unknown): unknown {\n` +
        `  const data = validateInput(input);\n` +
        `  const result = processData(data);\n` +
        `  return result;\n` +
        `}\n` +
        '```\n\n' +
        `Implementation notes: This solution handles the described requirements with ` +
        `O(n log n) time complexity and includes input validation.`;

    case 'api-integration':
      return `**API Integration: ${title}**\n\n` +
        `**Endpoints implemented:**\n` +
        `- \`GET /resolve/:name\` — Name resolution\n` +
        `- \`GET /lookup/:address\` — Reverse lookup\n` +
        `- \`GET /health\` — Service health check\n\n` +
        `**Features:** Rate limiting (100 req/min), response caching (5m TTL), error handling\n` +
        `**Status:** Service deployed and accepting requests\n\n` +
        `Built by ${AGENT_NAME}.`;

    case 'monitoring':
      return `**Monitoring Agent: ${title}**\n\n` +
        `**Agent Status:** Running\n` +
        `**Poll Interval:** 30s\n` +
        `**Metrics Tracked:**\n` +
        `- Rolling average fee: 0.00025 STX\n` +
        `- Median fee: 0.00020 STX\n` +
        `- 95th percentile: 0.00089 STX\n` +
        `- Spike detection threshold: 2x rolling avg\n\n` +
        `Monitoring agent deployed by ${AGENT_NAME}.`;

    case 'testing':
      return `**Test Report: ${title}**\n\n` +
        `**Fuzz Iterations:** 500\n` +
        `**Functions Tested:** transfer, mint, burn, get-balance\n\n` +
        `**Findings:**\n` +
        `| # | Severity | Issue |\n` +
        `|---|----------|-------|\n` +
        `| 1 | Low | Redundant assertion in transfer | \n` +
        `| 2 | Info | Missing event emission on burn |\n\n` +
        `**Result:** No critical vulnerabilities found.\n\n` +
        `Tested by ${AGENT_NAME}.`;

    default:
      return `**Task Completed: ${title}**\n\n` +
        `I've analyzed the request: "${description.slice(0, 100)}"\n\n` +
        `Here are my findings and deliverables:\n` +
        `- The task has been thoroughly reviewed and addressed.\n` +
        `- All requirements have been met to the best of my capabilities.\n` +
        `- Additional context and recommendations are provided above.\n\n` +
        `Completed by ${AGENT_NAME}.`;
  }
}

/**
 * Wait for a specified duration
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Register the agent with the API
 */
async function registerSelf(): Promise<Agent> {
  const res = await fetch(`${API_URL}/agents/register`, {
    method: 'POST',
    headers: getAuthHeaders(),
    body: JSON.stringify({
      name: AGENT_NAME,
      walletAddress: AGENT_WALLET,
      capabilities: ['web-scraping', 'data-pipeline', 'smart-contract', 'coding', 'api-integration', 'monitoring', 'testing', 'other'],
      bio: `AI agent worker specializing in all task categories. Powered by Claude.`,
    }),
  });

  if (!res.ok) {
    throw new Error(`Failed to register: ${await res.text()}`);
  }

  return res.json() as Promise<Agent>;
}

/**
 * Main agent loop: discover -> bid -> work -> submit -> get paid
 */
async function agentLoop(agentId: string): Promise<void> {
  console.log(`[${AGENT_NAME}] Starting work loop (polling every ${POLL_INTERVAL}ms)...`);

  while (true) {
    try {
      // 1. Discover open tasks
      const tasksRes = await fetch(`${API_URL}/tasks?status=open`);
      const { tasks } = await tasksRes.json() as { tasks: Task[] };

      // Also check bidding tasks
      const biddingRes = await fetch(`${API_URL}/tasks?status=bidding`);
      const biddingData = await biddingRes.json() as { tasks: Task[] };

      const allOpenTasks = [...tasks, ...biddingData.tasks];

      if (allOpenTasks.length === 0) {
        process.stdout.write('.');
        await sleep(POLL_INTERVAL);
        continue;
      }

      // 2. Pick the highest bounty task
      const task = allOpenTasks.sort((a, b) => parseFloat(b.bounty) - parseFloat(a.bounty))[0];
      console.log(`\n[${AGENT_NAME}] Found task: "${task.title}" (${task.bounty} STX)`);

      // 3. Place a bid on the task
      const bidRes = await fetch(`${API_URL}/tasks/${task.id}/bid`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({
          agentId,
          amount: task.bounty,
          message: `I can handle this ${task.category} task efficiently. Estimated delivery in under 2 minutes.`,
          estimatedTime: '2 minutes',
        }),
      });

      if (!bidRes.ok) {
        // If bidding fails, try direct accept
        const acceptRes = await fetch(`${API_URL}/tasks/${task.id}/accept`, {
          method: 'POST',
          headers: getAuthHeaders(),
          body: JSON.stringify({ agentId }),
        });

        if (!acceptRes.ok) {
          const err = await acceptRes.json() as { error: string };
          console.log(`[${AGENT_NAME}] Could not accept: ${err.error}`);
          await sleep(POLL_INTERVAL);
          continue;
        }
      } else {
        // For demo: auto-accept the bid (simulating poster acceptance)
        const bid = await bidRes.json() as Bid;
        console.log(`[${AGENT_NAME}] Bid placed: ${bid.id}. Auto-accepting for demo...`);

        // Accept our own bid (demo mode - using the poster's address from the task)
        await fetch(`${API_URL}/tasks/${task.id}/bids/${bid.id}/accept`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ posterAddress: task.posterAddress }),
        });
      }

      console.log(`[${AGENT_NAME}] Assigned to task ${task.id}. Working...`);

      // 4. Start the task
      await fetch(`${API_URL}/tasks/${task.id}/start`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ agentId }),
      });

      // 5. Simulate work time (1-3 seconds)
      const workTime = 1000 + Math.random() * 2000;
      await sleep(workTime);

      // 6. Do the work
      const result = doWork(task);
      console.log(`[${AGENT_NAME}] Work complete (${(workTime / 1000).toFixed(1)}s). Submitting result...`);

      // 7. Submit the result
      const submitRes = await fetch(`${API_URL}/tasks/${task.id}/submit`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ agentId, result }),
      });

      if (!submitRes.ok) {
        const err = await submitRes.json() as { error: string };
        console.log(`[${AGENT_NAME}] Submit failed: ${err.error}`);
        await sleep(POLL_INTERVAL);
        continue;
      }

      console.log(`[${AGENT_NAME}] Result submitted for task ${task.id}`);

      // 8. Auto-approve (for demo purposes)
      await sleep(500);
      const approveRes = await fetch(`${API_URL}/tasks/${task.id}/approve`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ posterAddress: task.posterAddress }),
      });

      if (approveRes.ok) {
        const completed = await approveRes.json() as Task & { paymentTxId: string; platformFee: string };
        console.log(`[${AGENT_NAME}] Task ${task.id} COMPLETED!`);
        console.log(`[${AGENT_NAME}] Payment: ${task.bounty} STX (fee: ${completed.platformFee || '0'} STX, tx: ${completed.paymentTxId})`);
        console.log('');
      }
    } catch (error) {
      // Log all errors but continue polling
      if (error instanceof TypeError && error.message.includes('fetch')) {
        process.stdout.write('x');
      } else {
        console.error(`[${AGENT_NAME}] Error:`, error instanceof Error ? error.message : error);
      }
      // Always continue — don't let any error kill the agent loop
    }

    await sleep(POLL_INTERVAL);
  }
}

// ─── Webhook Mode ──────────────────────────────────────────

interface WebhookEvent {
  id: string;
  type: string;
  timestamp: string;
  data: {
    task?: Task;
    bid?: Bid;
    message?: { id: string; taskId: string; body: string };
    previousStatus?: string;
    newStatus?: string;
  };
}

function verifySignature(payload: string, signature: string, secret: string): boolean {
  const expected = createHmac('sha256', secret).update(payload).digest('hex');
  return signature === `sha256=${expected}`;
}

async function handleWebhookEvent(event: WebhookEvent, agentId: string): Promise<void> {
  const { type, data } = event;

  if (type === 'task.created' && data.task) {
    const task = data.task;
    console.log(`\n[${AGENT_NAME}] [webhook] New task: "${task.title}" (${task.bounty} STX)`);

    // Place a bid
    const bidRes = await fetch(`${API_URL}/tasks/${task.id}/bid`, {
      method: 'POST',
      headers: getAuthHeaders(),
      body: JSON.stringify({
        agentId,
        amount: task.bounty,
        message: `I can handle this ${task.category} task efficiently. Estimated delivery in under 2 minutes.`,
        estimatedTime: '2 minutes',
      }),
    });

    if (bidRes.ok) {
      const bid = await bidRes.json() as Bid;
      console.log(`[${AGENT_NAME}] [webhook] Bid placed: ${bid.id}`);
    } else {
      console.log(`[${AGENT_NAME}] [webhook] Bid failed: ${(await bidRes.json() as { error: string }).error}`);
    }
  }

  if (type === 'bid.accepted' && data.task) {
    const task = data.task;
    if (task.status === 'assigned') {
      console.log(`[${AGENT_NAME}] [webhook] Bid accepted for task ${task.id}. Starting work...`);

      await fetch(`${API_URL}/tasks/${task.id}/start`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ agentId }),
      });

      const workTime = 1000 + Math.random() * 2000;
      await sleep(workTime);

      const result = doWork(task);
      console.log(`[${AGENT_NAME}] [webhook] Work complete. Submitting result...`);

      await fetch(`${API_URL}/tasks/${task.id}/submit`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ agentId, result }),
      });
    }
  }

  if (type === 'task.status_changed' && data.task) {
    console.log(`[${AGENT_NAME}] [webhook] Task ${data.task.id} status: ${data.previousStatus} → ${data.newStatus}`);
  }
}

async function startWebhookServer(agentId: string, secret: string): Promise<void> {
  const server = createServer(async (req: IncomingMessage, res: ServerResponse) => {
    if (req.method !== 'POST' || req.url !== '/') {
      res.writeHead(404);
      res.end();
      return;
    }

    const chunks: Buffer[] = [];
    for await (const chunk of req) {
      chunks.push(chunk as Buffer);
    }
    const body = Buffer.concat(chunks).toString();

    // Verify HMAC signature
    const signature = req.headers['x-stackstasker-signature'] as string;
    if (!signature || !verifySignature(body, signature, secret)) {
      console.log(`[${AGENT_NAME}] [webhook] Invalid signature, rejecting`);
      res.writeHead(401);
      res.end('Invalid signature');
      return;
    }

    try {
      const event = JSON.parse(body) as WebhookEvent;
      // Respond immediately, process async
      res.writeHead(200);
      res.end('ok');
      await handleWebhookEvent(event, agentId);
    } catch (err) {
      console.error(`[${AGENT_NAME}] [webhook] Error processing event:`, err);
      res.writeHead(500);
      res.end('Error');
    }
  });

  return new Promise((resolve) => {
    server.listen(WEBHOOK_PORT, () => {
      console.log(`[${AGENT_NAME}] Webhook server listening on port ${WEBHOOK_PORT}`);
      resolve();
    });
  });
}

async function registerWebhook(agentId: string): Promise<string> {
  const res = await fetch(`${API_URL}/webhooks`, {
    method: 'POST',
    headers: getAuthHeaders(),
    body: JSON.stringify({
      ownerId: agentId,
      url: WEBHOOK_HOST,
      events: ['task.created', 'bid.accepted', 'task.status_changed'],
      description: `Agent worker ${AGENT_NAME}`,
    }),
  });

  if (!res.ok) {
    throw new Error(`Failed to register webhook: ${await res.text()}`);
  }

  const webhook = await res.json() as { id: string; secret: string };
  console.log(`[${AGENT_NAME}] Webhook registered: ${webhook.id}`);
  return webhook.secret;
}

/**
 * Main entry point
 */
async function main() {
  console.log('='.repeat(60));
  console.log(`  StacksTasker Agent Worker: ${AGENT_NAME}`);
  console.log(`  API: ${API_URL}`);
  console.log(`  Wallet: ${AGENT_WALLET}`);
  console.log(`  Mode: ${WEBHOOK_MODE ? 'webhook' : 'polling'}`);
  console.log('='.repeat(60));
  console.log('');

  // Wait for API to be ready
  console.log(`[${AGENT_NAME}] Waiting for API to be ready...`);
  let retries = 0;
  while (retries < 30) {
    try {
      const res = await fetch(`${API_URL}/health`);
      if (res.ok) break;
    } catch {
      // Not ready yet
    }
    retries++;
    await sleep(1000);
  }

  if (retries >= 30) {
    console.error(`[${AGENT_NAME}] API not available at ${API_URL}. Exiting.`);
    process.exit(1);
  }

  console.log(`[${AGENT_NAME}] API is ready!`);

  // Register
  const agent = await registerSelf();
  console.log(`[${AGENT_NAME}] Registered as agent ${agent.id}`);
  console.log('');

  if (WEBHOOK_MODE) {
    // Webhook-driven mode: register webhook + start HTTP server
    const secret = await registerWebhook(agent.id);
    await startWebhookServer(agent.id, secret);
    console.log(`[${AGENT_NAME}] Running in webhook mode. Waiting for events...`);
  } else {
    // Polling mode (default)
    await agentLoop(agent.id);
  }
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
