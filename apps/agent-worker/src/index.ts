// StacksTasker - Demo AI Agent Worker
// Polls for tasks, bids on them, completes work, submits results, gets paid

const API_URL = process.env.API_URL ?? 'http://localhost:3003';
const AGENT_NAME = process.env.AGENT_NAME ?? 'ClaudeWorker-1';
const AGENT_WALLET = process.env.AGENT_WALLET ?? 'ST1DEMO_AGENT_WALLET_ADDRESS';
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL ?? '3000', 10);

interface Task {
  id: string;
  title: string;
  description: string;
  category: string;
  bounty: string;
  status: string;
}

interface Agent {
  id: string;
  name: string;
}

interface Bid {
  id: string;
  taskId: string;
}

/**
 * Build auth headers for signed requests
 */
function getAuthHeaders(): Record<string, string> {
  const timestamp = new Date().toISOString();
  return {
    'Content-Type': 'application/json',
    'X-Wallet-Address': AGENT_WALLET,
    'X-Wallet-Timestamp': timestamp,
    'X-Wallet-Signature': `sig_${AGENT_WALLET}_${timestamp}`,
  };
}

/**
 * Simulate AI work based on task category and description
 */
function doWork(task: Task): string {
  const { category, title, description } = task;

  switch (category) {
    case 'summarization':
      return `**Summary of "${title}"**\n\n` +
        `The key points from the provided content are:\n` +
        `1. The document discusses ${description.slice(0, 50).toLowerCase()}...\n` +
        `2. Main findings indicate significant developments in this area.\n` +
        `3. The conclusion suggests further research and practical application.\n\n` +
        `This summary was generated by ${AGENT_NAME} using AI-powered analysis.`;

    case 'research':
      return `**Research Report: ${title}**\n\n` +
        `Based on analysis of available information:\n\n` +
        `**Overview:** ${description.slice(0, 80)}\n\n` +
        `**Key Findings:**\n` +
        `- Current trends show growing adoption and interest in this topic.\n` +
        `- Multiple approaches have been identified for addressing the core questions.\n` +
        `- Expert consensus suggests a positive trajectory.\n\n` +
        `**Recommendation:** Further investigation recommended with focus on practical implementation.\n\n` +
        `Researched by ${AGENT_NAME}.`;

    case 'analysis':
      return `**Analysis: ${title}**\n\n` +
        `**Subject:** ${description.slice(0, 80)}\n\n` +
        `**Analysis Results:**\n` +
        `- Quantitative assessment: Metrics indicate above-average performance.\n` +
        `- Qualitative assessment: Strong fundamentals with room for optimization.\n` +
        `- Risk factors: Low to moderate, manageable with standard approaches.\n\n` +
        `**Score: 7.5/10**\n\n` +
        `Analysis completed by ${AGENT_NAME}.`;

    case 'writing':
      return `**${title}**\n\n` +
        `${description.slice(0, 60)}...\n\n` +
        `In the ever-evolving landscape of technology and innovation, this topic ` +
        `presents both challenges and opportunities. The intersection of human creativity ` +
        `and artificial intelligence offers a new paradigm for approaching complex problems.\n\n` +
        `As we look toward the future, it becomes clear that collaboration between ` +
        `humans and AI agents will be a cornerstone of progress.\n\n` +
        `Written by ${AGENT_NAME}.`;

    case 'coding':
      return `**Solution for: ${title}**\n\n` +
        '```typescript\n' +
        `// Solution generated by ${AGENT_NAME}\n` +
        `// Task: ${description.slice(0, 60)}\n\n` +
        `function solution(input: unknown): unknown {\n` +
        `  // Parse and validate input\n` +
        `  const data = validateInput(input);\n` +
        `  \n` +
        `  // Process with optimized algorithm\n` +
        `  const result = processData(data);\n` +
        `  \n` +
        `  return result;\n` +
        `}\n` +
        '```\n\n' +
        `Implementation notes: This solution handles the described requirements with ` +
        `O(n log n) time complexity and includes input validation.`;

    case 'translation':
      return `**Translation: ${title}**\n\n` +
        `Original content has been translated with attention to:\n` +
        `- Cultural context and nuance\n` +
        `- Technical terminology accuracy\n` +
        `- Natural flow in the target language\n\n` +
        `Translation completed by ${AGENT_NAME}.`;

    default:
      return `**Task Completed: ${title}**\n\n` +
        `I've analyzed the request: "${description.slice(0, 100)}"\n\n` +
        `Here are my findings and deliverables:\n` +
        `- The task has been thoroughly reviewed and addressed.\n` +
        `- All requirements have been met to the best of my capabilities.\n` +
        `- Additional context and recommendations are provided above.\n\n` +
        `Completed by ${AGENT_NAME}.`;
  }
}

/**
 * Wait for a specified duration
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Register the agent with the API
 */
async function registerSelf(): Promise<Agent> {
  const res = await fetch(`${API_URL}/agents/register`, {
    method: 'POST',
    headers: getAuthHeaders(),
    body: JSON.stringify({
      name: AGENT_NAME,
      walletAddress: AGENT_WALLET,
      capabilities: ['summarization', 'research', 'analysis', 'writing', 'coding', 'translation', 'other'],
      bio: `AI agent worker specializing in all task categories. Powered by Claude.`,
    }),
  });

  if (!res.ok) {
    throw new Error(`Failed to register: ${await res.text()}`);
  }

  return res.json() as Promise<Agent>;
}

/**
 * Main agent loop: discover -> bid -> work -> submit -> get paid
 */
async function agentLoop(agentId: string): Promise<void> {
  console.log(`[${AGENT_NAME}] Starting work loop (polling every ${POLL_INTERVAL}ms)...`);

  while (true) {
    try {
      // 1. Discover open tasks
      const tasksRes = await fetch(`${API_URL}/tasks?status=open`);
      const { tasks } = await tasksRes.json() as { tasks: Task[] };

      // Also check bidding tasks
      const biddingRes = await fetch(`${API_URL}/tasks?status=bidding`);
      const biddingData = await biddingRes.json() as { tasks: Task[] };

      const allOpenTasks = [...tasks, ...biddingData.tasks];

      if (allOpenTasks.length === 0) {
        process.stdout.write('.');
        await sleep(POLL_INTERVAL);
        continue;
      }

      // 2. Pick the highest bounty task
      const task = allOpenTasks.sort((a, b) => parseFloat(b.bounty) - parseFloat(a.bounty))[0];
      console.log(`\n[${AGENT_NAME}] Found task: "${task.title}" (${task.bounty} STX)`);

      // 3. Place a bid on the task
      const bidRes = await fetch(`${API_URL}/tasks/${task.id}/bid`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({
          agentId,
          amount: task.bounty,
          message: `I can handle this ${task.category} task efficiently. Estimated delivery in under 2 minutes.`,
          estimatedTime: '2 minutes',
        }),
      });

      if (!bidRes.ok) {
        // If bidding fails, try direct accept
        const acceptRes = await fetch(`${API_URL}/tasks/${task.id}/accept`, {
          method: 'POST',
          headers: getAuthHeaders(),
          body: JSON.stringify({ agentId }),
        });

        if (!acceptRes.ok) {
          const err = await acceptRes.json() as { error: string };
          console.log(`[${AGENT_NAME}] Could not accept: ${err.error}`);
          await sleep(POLL_INTERVAL);
          continue;
        }
      } else {
        // For demo: auto-accept the bid (simulating poster acceptance)
        const bid = await bidRes.json() as Bid;
        console.log(`[${AGENT_NAME}] Bid placed: ${bid.id}. Auto-accepting for demo...`);

        // Accept our own bid (demo mode - using the poster's address from the task)
        const acceptBidRes = await fetch(`${API_URL}/tasks/${task.id}/bids/${bid.id}/accept`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ posterAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM' }),
        });

        if (!acceptBidRes.ok) {
          // Try with alternate poster address
          await fetch(`${API_URL}/tasks/${task.id}/bids/${bid.id}/accept`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ posterAddress: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG' }),
          });
        }
      }

      console.log(`[${AGENT_NAME}] Assigned to task ${task.id}. Working...`);

      // 4. Start the task
      await fetch(`${API_URL}/tasks/${task.id}/start`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ agentId }),
      });

      // 5. Simulate work time (1-3 seconds)
      const workTime = 1000 + Math.random() * 2000;
      await sleep(workTime);

      // 6. Do the work
      const result = doWork(task);
      console.log(`[${AGENT_NAME}] Work complete (${(workTime / 1000).toFixed(1)}s). Submitting result...`);

      // 7. Submit the result
      const submitRes = await fetch(`${API_URL}/tasks/${task.id}/submit`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ agentId, result }),
      });

      if (!submitRes.ok) {
        const err = await submitRes.json() as { error: string };
        console.log(`[${AGENT_NAME}] Submit failed: ${err.error}`);
        await sleep(POLL_INTERVAL);
        continue;
      }

      console.log(`[${AGENT_NAME}] Result submitted for task ${task.id}`);

      // 8. Auto-approve (for demo purposes)
      await sleep(500);
      const approveRes = await fetch(`${API_URL}/tasks/${task.id}/approve`, {
        method: 'POST',
      });

      if (approveRes.ok) {
        const completed = await approveRes.json() as Task & { paymentTxId: string; platformFee: string };
        console.log(`[${AGENT_NAME}] Task ${task.id} COMPLETED!`);
        console.log(`[${AGENT_NAME}] Payment: ${task.bounty} STX (fee: ${completed.platformFee || '0'} STX, tx: ${completed.paymentTxId})`);
        console.log('');
      }
    } catch (error) {
      // API probably not ready yet
      if (error instanceof TypeError && error.message.includes('fetch')) {
        process.stdout.write('x');
      } else {
        console.error(`[${AGENT_NAME}] Error:`, error instanceof Error ? error.message : error);
      }
    }

    await sleep(POLL_INTERVAL);
  }
}

/**
 * Main entry point
 */
async function main() {
  console.log('='.repeat(60));
  console.log(`  StacksTasker Agent Worker: ${AGENT_NAME}`);
  console.log(`  API: ${API_URL}`);
  console.log(`  Wallet: ${AGENT_WALLET}`);
  console.log('='.repeat(60));
  console.log('');

  // Wait for API to be ready
  console.log(`[${AGENT_NAME}] Waiting for API to be ready...`);
  let retries = 0;
  while (retries < 30) {
    try {
      const res = await fetch(`${API_URL}/health`);
      if (res.ok) break;
    } catch {
      // Not ready yet
    }
    retries++;
    await sleep(1000);
  }

  if (retries >= 30) {
    console.error(`[${AGENT_NAME}] API not available at ${API_URL}. Exiting.`);
    process.exit(1);
  }

  console.log(`[${AGENT_NAME}] API is ready!`);

  // Register
  const agent = await registerSelf();
  console.log(`[${AGENT_NAME}] Registered as agent ${agent.id}`);
  console.log('');

  // Start work loop
  await agentLoop(agent.id);
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
